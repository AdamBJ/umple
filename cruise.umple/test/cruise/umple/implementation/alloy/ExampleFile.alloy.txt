/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 34 "../../../../../../ump/tmp746386/model.ump"
// line 111 "../../../../../../ump/tmp746386/model.ump"
public class Account
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Account Attributes
  private int accountNumber;
  private float balance;
  private float creditLimit;

  //Account Associations
  private AccountType accountType;
  private List<Client> clients;
  private Branch branch;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Account(int aAccountNumber, float aBalance, float aCreditLimit, AccountType aAccountType, Branch aBranch)
  {
    accountNumber = aAccountNumber;
    balance = aBalance;
    creditLimit = aCreditLimit;
    if (!setAccountType(aAccountType))
    {
      throw new RuntimeException("Unable to create Account due to aAccountType");
    }
    clients = new ArrayList<Client>();
    boolean didAddBranch = setBranch(aBranch);
    if (!didAddBranch)
    {
      throw new RuntimeException("Unable to create account due to branch");
    }
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setAccountNumber(int aAccountNumber)
  {
    boolean wasSet = false;
    accountNumber = aAccountNumber;
    wasSet = true;
    return wasSet;
  }

  public boolean setBalance(float aBalance)
  {
    boolean wasSet = false;
    balance = aBalance;
    wasSet = true;
    return wasSet;
  }

  public boolean setCreditLimit(float aCreditLimit)
  {
    boolean wasSet = false;
    creditLimit = aCreditLimit;
    wasSet = true;
    return wasSet;
  }

  public int getAccountNumber()
  {
    return accountNumber;
  }

  public float getBalance()
  {
    return balance;
  }

  public float getCreditLimit()
  {
    return creditLimit;
  }

  public AccountType getAccountType()
  {
    return accountType;
  }

  public Client getClient(int index)
  {
    Client aClient = clients.get(index);
    return aClient;
  }

  public List<Client> getClients()
  {
    List<Client> newClients = Collections.unmodifiableList(clients);
    return newClients;
  }

  public int numberOfClients()
  {
    int number = clients.size();
    return number;
  }

  public boolean hasClients()
  {
    boolean has = clients.size() > 0;
    return has;
  }

  public int indexOfClient(Client aClient)
  {
    int index = clients.indexOf(aClient);
    return index;
  }

  public Branch getBranch()
  {
    return branch;
  }

  public boolean setAccountType(AccountType aNewAccountType)
  {
    boolean wasSet = false;
    if (aNewAccountType != null)
    {
      accountType = aNewAccountType;
      wasSet = true;
    }
    return wasSet;
  }

  public boolean isNumberOfClientsValid()
  {
    boolean isValid = numberOfClients() >= minimumNumberOfClients() && numberOfClients() <= maximumNumberOfClients();
    return isValid;
  }

  public static int minimumNumberOfClients()
  {
    return 1;
  }

  public static int maximumNumberOfClients()
  {
    return 2;
  }

  public boolean addClient(Client aClient)
  {
    boolean wasAdded = false;
    if (clients.contains(aClient)) { return false; }
    if (numberOfClients() >= maximumNumberOfClients())
    {
      return wasAdded;
    }

    clients.add(aClient);
    if (aClient.indexOfAccount(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aClient.addAccount(this);
      if (!wasAdded)
      {
        clients.remove(aClient);
      }
    }
    return wasAdded;
  }

  public boolean removeClient(Client aClient)
  {
    boolean wasRemoved = false;
    if (!clients.contains(aClient))
    {
      return wasRemoved;
    }

    if (numberOfClients() <= minimumNumberOfClients())
    {
      return wasRemoved;
    }

    int oldIndex = clients.indexOf(aClient);
    clients.remove(oldIndex);
    if (aClient.indexOfAccount(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aClient.removeAccount(this);
      if (!wasRemoved)
      {
        clients.add(oldIndex,aClient);
      }
    }
    return wasRemoved;
  }

  public boolean setClients(Client... newClients)
  {
    boolean wasSet = false;
    ArrayList<Client> verifiedClients = new ArrayList<Client>();
    for (Client aClient : newClients)
    {
      if (verifiedClients.contains(aClient))
      {
        continue;
      }
      verifiedClients.add(aClient);
    }

    if (verifiedClients.size() != newClients.length || verifiedClients.size() < minimumNumberOfClients() || verifiedClients.size() > maximumNumberOfClients())
    {
      return wasSet;
    }

    ArrayList<Client> oldClients = new ArrayList<Client>(clients);
    clients.clear();
    for (Client aNewClient : verifiedClients)
    {
      clients.add(aNewClient);
      if (oldClients.contains(aNewClient))
      {
        oldClients.remove(aNewClient);
      }
      else
      {
        aNewClient.addAccount(this);
      }
    }

    for (Client anOldClient : oldClients)
    {
      anOldClient.removeAccount(this);
    }
    wasSet = true;
    return wasSet;
  }

  public boolean addClientAt(Client aClient, int index)
  {  
    boolean wasAdded = false;
    if(addClient(aClient))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfClients()) { index = numberOfClients() - 1; }
      clients.remove(aClient);
      clients.add(index, aClient);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveClientAt(Client aClient, int index)
  {
    boolean wasAdded = false;
    if(clients.contains(aClient))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfClients()) { index = numberOfClients() - 1; }
      clients.remove(aClient);
      clients.add(index, aClient);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addClientAt(aClient, index);
    }
    return wasAdded;
  }

  public boolean setBranch(Branch aBranch)
  {
    boolean wasSet = false;
    if (aBranch == null)
    {
      return wasSet;
    }

    Branch existingBranch = branch;
    branch = aBranch;
    if (existingBranch != null && !existingBranch.equals(aBranch))
    {
      existingBranch.removeAccount(this);
    }
    branch.addAccount(this);
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    accountType = null;
    ArrayList<Client> copyOfClients = new ArrayList<Client>(clients);
    clients.clear();
    for(Client aClient : copyOfClients)
    {
      if (aClient.numberOfAccounts() <= Client.minimumNumberOfAccounts())
      {
        aClient.delete();
      }
      else
      {
        aClient.removeAccount(this);
      }
    }
    Branch placeholderBranch = branch;
    this.branch = null;
    placeholderBranch.removeAccount(this);
  }


  public String toString()
  {
    return super.toString() + "["+
            "accountNumber" + ":" + getAccountNumber()+ "," +
            "balance" + ":" + getBalance()+ "," +
            "creditLimit" + ":" + getCreditLimit()+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "accountType = "+(getAccountType()!=null?Integer.toHexString(System.identityHashCode(getAccountType())):"null") + System.getProperties().getProperty("line.separator") +
            "  " + "branch = "+(getBranch()!=null?Integer.toHexString(System.identityHashCode(getBranch())):"null");
  }
}



//%% NEW FILE CreditCardAccount BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.sql.Date;
import java.util.*;

// line 54 "../../../../../../ump/tmp746386/model.ump"
// line 126 "../../../../../../ump/tmp746386/model.ump"
public class CreditCardAccount extends Account
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //CreditCardAccount Attributes
  private Date expiryDate;

  //CreditCardAccount Associations
  private List<Card> cards;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public CreditCardAccount(int aAccountNumber, float aBalance, float aCreditLimit, AccountType aAccountType, Branch aBranch, Date aExpiryDate)
  {
    super(aAccountNumber, aBalance, aCreditLimit, aAccountType, aBranch);
    expiryDate = aExpiryDate;
    cards = new ArrayList<Card>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setExpiryDate(Date aExpiryDate)
  {
    boolean wasSet = false;
    expiryDate = aExpiryDate;
    wasSet = true;
    return wasSet;
  }

  public Date getExpiryDate()
  {
    return expiryDate;
  }

  public Card getCard(int index)
  {
    Card aCard = cards.get(index);
    return aCard;
  }

  public List<Card> getCards()
  {
    List<Card> newCards = Collections.unmodifiableList(cards);
    return newCards;
  }

  public int numberOfCards()
  {
    int number = cards.size();
    return number;
  }

  public boolean hasCards()
  {
    boolean has = cards.size() > 0;
    return has;
  }

  public int indexOfCard(Card aCard)
  {
    int index = cards.indexOf(aCard);
    return index;
  }

  public boolean isNumberOfCardsValid()
  {
    boolean isValid = numberOfCards() >= minimumNumberOfCards();
    return isValid;
  }

  public static int minimumNumberOfCards()
  {
    return 1;
  }

  public Card addCard(String aHolderName)
  {
    Card aNewCard = new Card(aHolderName, this);
    return aNewCard;
  }

  public boolean addCard(Card aCard)
  {
    boolean wasAdded = false;
    if (cards.contains(aCard)) { return false; }
    CreditCardAccount existingCreditCardAccount = aCard.getCreditCardAccount();
    boolean isNewCreditCardAccount = existingCreditCardAccount != null && !this.equals(existingCreditCardAccount);

    if (isNewCreditCardAccount && existingCreditCardAccount.numberOfCards() <= minimumNumberOfCards())
    {
      return wasAdded;
    }
    if (isNewCreditCardAccount)
    {
      aCard.setCreditCardAccount(this);
    }
    else
    {
      cards.add(aCard);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeCard(Card aCard)
  {
    boolean wasRemoved = false;
    //Unable to remove aCard, as it must always have a creditCardAccount
    if (this.equals(aCard.getCreditCardAccount()))
    {
      return wasRemoved;
    }

    //creditCardAccount already at minimum (1)
    if (numberOfCards() <= minimumNumberOfCards())
    {
      return wasRemoved;
    }

    cards.remove(aCard);
    wasRemoved = true;
    return wasRemoved;
  }

  public boolean addCardAt(Card aCard, int index)
  {  
    boolean wasAdded = false;
    if(addCard(aCard))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfCards()) { index = numberOfCards() - 1; }
      cards.remove(aCard);
      cards.add(index, aCard);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveCardAt(Card aCard, int index)
  {
    boolean wasAdded = false;
    if(cards.contains(aCard))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfCards()) { index = numberOfCards() - 1; }
      cards.remove(aCard);
      cards.add(index, aCard);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addCardAt(aCard, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    for(int i=cards.size(); i > 0; i--)
    {
      Card aCard = cards.get(i - 1);
      aCard.delete();
    }
    super.delete();
  }


  public String toString()
  {
    return super.toString() + "["+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "expiryDate" + "=" + (getExpiryDate() != null ? !getExpiryDate().equals(this)  ? getExpiryDate().toString().replaceAll("  ","    ") : "this" : "null");
  }
}



//%% NEW FILE Manager BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 29 "../../../../../../ump/tmp746386/model.ump"
// line 106 "../../../../../../ump/tmp746386/model.ump"
public class Manager extends Employee
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Manager Associations
  private List<Employee> employees;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Manager(Person aPerson, Division aDivision)
  {
    super(aPerson, aDivision);
    employees = new ArrayList<Employee>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public Employee getEmployee(int index)
  {
    Employee aEmployee = employees.get(index);
    return aEmployee;
  }

  public List<Employee> getEmployees()
  {
    List<Employee> newEmployees = Collections.unmodifiableList(employees);
    return newEmployees;
  }

  public int numberOfEmployees()
  {
    int number = employees.size();
    return number;
  }

  public boolean hasEmployees()
  {
    boolean has = employees.size() > 0;
    return has;
  }

  public int indexOfEmployee(Employee aEmployee)
  {
    int index = employees.indexOf(aEmployee);
    return index;
  }

  public static int minimumNumberOfEmployees()
  {
    return 0;
  }

  public boolean addEmployee(Employee aEmployee)
  {
    boolean wasAdded = false;
    if (employees.contains(aEmployee)) { return false; }
    Manager existingManager = aEmployee.getManager();
    if (existingManager == null)
    {
      aEmployee.setManager(this);
    }
    else if (!this.equals(existingManager))
    {
      existingManager.removeEmployee(aEmployee);
      addEmployee(aEmployee);
    }
    else
    {
      employees.add(aEmployee);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeEmployee(Employee aEmployee)
  {
    boolean wasRemoved = false;
    if (employees.contains(aEmployee))
    {
      employees.remove(aEmployee);
      aEmployee.setManager(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  public boolean addEmployeeAt(Employee aEmployee, int index)
  {  
    boolean wasAdded = false;
    if(addEmployee(aEmployee))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEmployees()) { index = numberOfEmployees() - 1; }
      employees.remove(aEmployee);
      employees.add(index, aEmployee);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveEmployeeAt(Employee aEmployee, int index)
  {
    boolean wasAdded = false;
    if(employees.contains(aEmployee))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEmployees()) { index = numberOfEmployees() - 1; }
      employees.remove(aEmployee);
      employees.add(index, aEmployee);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addEmployeeAt(aEmployee, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    while( !employees.isEmpty() )
    {
      employees.get(0).setManager(null);
    }
    super.delete();
  }

}



//%% NEW FILE AccountType BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 41 "../../../../../../ump/tmp746386/model.ump"
// line 116 "../../../../../../ump/tmp746386/model.ump"
public class AccountType
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //AccountType Attributes
  private float monthlyFee;
  private float interestRate;

  //AccountType Associations
  private List<Privilege> privileges;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public AccountType(float aMonthlyFee, float aInterestRate)
  {
    monthlyFee = aMonthlyFee;
    interestRate = aInterestRate;
    privileges = new ArrayList<Privilege>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setMonthlyFee(float aMonthlyFee)
  {
    boolean wasSet = false;
    monthlyFee = aMonthlyFee;
    wasSet = true;
    return wasSet;
  }

  public boolean setInterestRate(float aInterestRate)
  {
    boolean wasSet = false;
    interestRate = aInterestRate;
    wasSet = true;
    return wasSet;
  }

  public float getMonthlyFee()
  {
    return monthlyFee;
  }

  public float getInterestRate()
  {
    return interestRate;
  }

  public Privilege getPrivilege(int index)
  {
    Privilege aPrivilege = privileges.get(index);
    return aPrivilege;
  }

  public List<Privilege> getPrivileges()
  {
    List<Privilege> newPrivileges = Collections.unmodifiableList(privileges);
    return newPrivileges;
  }

  public int numberOfPrivileges()
  {
    int number = privileges.size();
    return number;
  }

  public boolean hasPrivileges()
  {
    boolean has = privileges.size() > 0;
    return has;
  }

  public int indexOfPrivilege(Privilege aPrivilege)
  {
    int index = privileges.indexOf(aPrivilege);
    return index;
  }

  public static int minimumNumberOfPrivileges()
  {
    return 0;
  }

  public boolean addPrivilege(Privilege aPrivilege)
  {
    boolean wasAdded = false;
    if (privileges.contains(aPrivilege)) { return false; }
    privileges.add(aPrivilege);
    if (aPrivilege.indexOfAccountType(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aPrivilege.addAccountType(this);
      if (!wasAdded)
      {
        privileges.remove(aPrivilege);
      }
    }
    return wasAdded;
  }

  public boolean removePrivilege(Privilege aPrivilege)
  {
    boolean wasRemoved = false;
    if (!privileges.contains(aPrivilege))
    {
      return wasRemoved;
    }

    int oldIndex = privileges.indexOf(aPrivilege);
    privileges.remove(oldIndex);
    if (aPrivilege.indexOfAccountType(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aPrivilege.removeAccountType(this);
      if (!wasRemoved)
      {
        privileges.add(oldIndex,aPrivilege);
      }
    }
    return wasRemoved;
  }

  public boolean addPrivilegeAt(Privilege aPrivilege, int index)
  {  
    boolean wasAdded = false;
    if(addPrivilege(aPrivilege))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPrivileges()) { index = numberOfPrivileges() - 1; }
      privileges.remove(aPrivilege);
      privileges.add(index, aPrivilege);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePrivilegeAt(Privilege aPrivilege, int index)
  {
    boolean wasAdded = false;
    if(privileges.contains(aPrivilege))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPrivileges()) { index = numberOfPrivileges() - 1; }
      privileges.remove(aPrivilege);
      privileges.add(index, aPrivilege);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPrivilegeAt(aPrivilege, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    ArrayList<Privilege> copyOfPrivileges = new ArrayList<Privilege>(privileges);
    privileges.clear();
    for(Privilege aPrivilege : copyOfPrivileges)
    {
      aPrivilege.removeAccountType(this);
    }
  }


  public String toString()
  {
    return super.toString() + "["+
            "monthlyFee" + ":" + getMonthlyFee()+ "," +
            "interestRate" + ":" + getInterestRate()+ "]";
  }
}



//%% NEW FILE PersonRole BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;

// line 6 "../../../../../../ump/tmp746386/model.ump"
// line 86 "../../../../../../ump/tmp746386/model.ump"
public class PersonRole
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //PersonRole Associations
  private Person person;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public PersonRole(Person aPerson)
  {
    boolean didAddPerson = setPerson(aPerson);
    if (!didAddPerson)
    {
      throw new RuntimeException("Unable to create personRole due to person");
    }
  }

  //------------------------
  // INTERFACE
  //------------------------

  public Person getPerson()
  {
    return person;
  }

  public boolean setPerson(Person aPerson)
  {
    boolean wasSet = false;
    if (aPerson == null)
    {
      return wasSet;
    }

    Person existingPerson = person;
    person = aPerson;
    if (existingPerson != null && !existingPerson.equals(aPerson))
    {
      existingPerson.removePersonRole(this);
    }
    person.addPersonRole(this);
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    Person placeholderPerson = person;
    this.person = null;
    placeholderPerson.removePersonRole(this);
  }

}



//%% NEW FILE Card BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;

// line 66 "../../../../../../ump/tmp746386/model.ump"
// line 136 "../../../../../../ump/tmp746386/model.ump"
public class Card
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Card Attributes
  private String holderName;

  //Card Associations
  private CreditCardAccount creditCardAccount;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Card(String aHolderName, CreditCardAccount aCreditCardAccount)
  {
    holderName = aHolderName;
    boolean didAddCreditCardAccount = setCreditCardAccount(aCreditCardAccount);
    if (!didAddCreditCardAccount)
    {
      throw new RuntimeException("Unable to create card due to creditCardAccount");
    }
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setHolderName(String aHolderName)
  {
    boolean wasSet = false;
    holderName = aHolderName;
    wasSet = true;
    return wasSet;
  }

  public String getHolderName()
  {
    return holderName;
  }

  public CreditCardAccount getCreditCardAccount()
  {
    return creditCardAccount;
  }

  public boolean setCreditCardAccount(CreditCardAccount aCreditCardAccount)
  {
    boolean wasSet = false;
    //Must provide creditCardAccount to card
    if (aCreditCardAccount == null)
    {
      return wasSet;
    }

    if (creditCardAccount != null && creditCardAccount.numberOfCards() <= CreditCardAccount.minimumNumberOfCards())
    {
      return wasSet;
    }

    CreditCardAccount existingCreditCardAccount = creditCardAccount;
    creditCardAccount = aCreditCardAccount;
    if (existingCreditCardAccount != null && !existingCreditCardAccount.equals(aCreditCardAccount))
    {
      boolean didRemove = existingCreditCardAccount.removeCard(this);
      if (!didRemove)
      {
        creditCardAccount = existingCreditCardAccount;
        return wasSet;
      }
    }
    creditCardAccount.addCard(this);
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    CreditCardAccount placeholderCreditCardAccount = creditCardAccount;
    this.creditCardAccount = null;
    placeholderCreditCardAccount.removeCard(this);
  }


  public String toString()
  {
    return super.toString() + "["+
            "holderName" + ":" + getHolderName()+ "]" + System.getProperties().getProperty("line.separator") +
            "  " + "creditCardAccount = "+(getCreditCardAccount()!=null?Integer.toHexString(System.identityHashCode(getCreditCardAccount())):"null");
  }
}



//%% NEW FILE Employee BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;

// line 16 "../../../../../../ump/tmp746386/model.ump"
// line 96 "../../../../../../ump/tmp746386/model.ump"
public class Employee extends PersonRole
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Employee Associations
  private Manager manager;
  private Division division;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Employee(Person aPerson, Division aDivision)
  {
    super(aPerson);
    boolean didAddDivision = setDivision(aDivision);
    if (!didAddDivision)
    {
      throw new RuntimeException("Unable to create employee due to division");
    }
  }

  //------------------------
  // INTERFACE
  //------------------------

  public Manager getManager()
  {
    return manager;
  }

  public boolean hasManager()
  {
    boolean has = manager != null;
    return has;
  }

  public Division getDivision()
  {
    return division;
  }

  public boolean setManager(Manager aManager)
  {
    boolean wasSet = false;
    Manager existingManager = manager;
    manager = aManager;
    if (existingManager != null && !existingManager.equals(aManager))
    {
      existingManager.removeEmployee(this);
    }
    if (aManager != null)
    {
      aManager.addEmployee(this);
    }
    wasSet = true;
    return wasSet;
  }

  public boolean setDivision(Division aDivision)
  {
    boolean wasSet = false;
    if (aDivision == null)
    {
      return wasSet;
    }

    Division existingDivision = division;
    division = aDivision;
    if (existingDivision != null && !existingDivision.equals(aDivision))
    {
      existingDivision.removeEmployee(this);
    }
    division.addEmployee(this);
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    if (manager != null)
    {
      Manager placeholderManager = manager;
      this.manager = null;
      placeholderManager.removeEmployee(this);
    }
    Division placeholderDivision = division;
    this.division = null;
    placeholderDivision.removeEmployee(this);
    super.delete();
  }

}



//%% NEW FILE MortgageAccount BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 61 "../../../../../../ump/tmp746386/model.ump"
// line 131 "../../../../../../ump/tmp746386/model.ump"
public class MortgageAccount extends Account
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //MortgageAccount Attributes
  private String collateral;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public MortgageAccount(int aAccountNumber, float aBalance, float aCreditLimit, AccountType aAccountType, Branch aBranch, String aCollateral)
  {
    super(aAccountNumber, aBalance, aCreditLimit, aAccountType, aBranch);
    collateral = aCollateral;
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setCollateral(String aCollateral)
  {
    boolean wasSet = false;
    collateral = aCollateral;
    wasSet = true;
    return wasSet;
  }

  public String getCollateral()
  {
    return collateral;
  }

  public void delete()
  {
    super.delete();
  }


  public String toString()
  {
    return super.toString() + "["+
            "collateral" + ":" + getCollateral()+ "]";
  }
}



//%% NEW FILE Branch BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 71 "../../../../../../ump/tmp746386/model.ump"
// line 141 "../../../../../../ump/tmp746386/model.ump"
public class Branch extends Division
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Branch Attributes
  private String address;
  private String branchNumber;

  //Branch Associations
  private List<Account> accounts;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Branch(String aName, String aAddress, String aBranchNumber)
  {
    super(aName);
    address = aAddress;
    branchNumber = aBranchNumber;
    accounts = new ArrayList<Account>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setAddress(String aAddress)
  {
    boolean wasSet = false;
    address = aAddress;
    wasSet = true;
    return wasSet;
  }

  public boolean setBranchNumber(String aBranchNumber)
  {
    boolean wasSet = false;
    branchNumber = aBranchNumber;
    wasSet = true;
    return wasSet;
  }

  public String getAddress()
  {
    return address;
  }

  public String getBranchNumber()
  {
    return branchNumber;
  }

  public Account getAccount(int index)
  {
    Account aAccount = accounts.get(index);
    return aAccount;
  }

  public List<Account> getAccounts()
  {
    List<Account> newAccounts = Collections.unmodifiableList(accounts);
    return newAccounts;
  }

  public int numberOfAccounts()
  {
    int number = accounts.size();
    return number;
  }

  public boolean hasAccounts()
  {
    boolean has = accounts.size() > 0;
    return has;
  }

  public int indexOfAccount(Account aAccount)
  {
    int index = accounts.indexOf(aAccount);
    return index;
  }

  public static int minimumNumberOfAccounts()
  {
    return 0;
  }

  public Account addAccount(int aAccountNumber, float aBalance, float aCreditLimit, AccountType aAccountType)
  {
    return new Account(aAccountNumber, aBalance, aCreditLimit, aAccountType, this);
  }

  public boolean addAccount(Account aAccount)
  {
    boolean wasAdded = false;
    if (accounts.contains(aAccount)) { return false; }
    Branch existingBranch = aAccount.getBranch();
    boolean isNewBranch = existingBranch != null && !this.equals(existingBranch);
    if (isNewBranch)
    {
      aAccount.setBranch(this);
    }
    else
    {
      accounts.add(aAccount);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeAccount(Account aAccount)
  {
    boolean wasRemoved = false;
    //Unable to remove aAccount, as it must always have a branch
    if (!this.equals(aAccount.getBranch()))
    {
      accounts.remove(aAccount);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  public boolean addAccountAt(Account aAccount, int index)
  {  
    boolean wasAdded = false;
    if(addAccount(aAccount))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccounts()) { index = numberOfAccounts() - 1; }
      accounts.remove(aAccount);
      accounts.add(index, aAccount);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveAccountAt(Account aAccount, int index)
  {
    boolean wasAdded = false;
    if(accounts.contains(aAccount))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccounts()) { index = numberOfAccounts() - 1; }
      accounts.remove(aAccount);
      accounts.add(index, aAccount);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addAccountAt(aAccount, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    for(int i=accounts.size(); i > 0; i--)
    {
      Account aAccount = accounts.get(i - 1);
      aAccount.delete();
    }
    super.delete();
  }


  public String toString()
  {
    return super.toString() + "["+
            "address" + ":" + getAddress()+ "," +
            "branchNumber" + ":" + getBranchNumber()+ "]";
  }
}



//%% NEW FILE Division BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 79 "../../../../../../ump/tmp746386/model.ump"
// line 146 "../../../../../../ump/tmp746386/model.ump"
public class Division
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Division Attributes
  private String name;

  //Division Associations
  private List<Employee> employees;
  private List<Division> subDivision;
  private Division division;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Division(String aName)
  {
    name = aName;
    employees = new ArrayList<Employee>();
    subDivision = new ArrayList<Division>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setName(String aName)
  {
    boolean wasSet = false;
    name = aName;
    wasSet = true;
    return wasSet;
  }

  public String getName()
  {
    return name;
  }

  public Employee getEmployee(int index)
  {
    Employee aEmployee = employees.get(index);
    return aEmployee;
  }

  public List<Employee> getEmployees()
  {
    List<Employee> newEmployees = Collections.unmodifiableList(employees);
    return newEmployees;
  }

  public int numberOfEmployees()
  {
    int number = employees.size();
    return number;
  }

  public boolean hasEmployees()
  {
    boolean has = employees.size() > 0;
    return has;
  }

  public int indexOfEmployee(Employee aEmployee)
  {
    int index = employees.indexOf(aEmployee);
    return index;
  }

  public Division getSubDivision(int index)
  {
    Division aSubDivision = subDivision.get(index);
    return aSubDivision;
  }

  public List<Division> getSubDivision()
  {
    List<Division> newSubDivision = Collections.unmodifiableList(subDivision);
    return newSubDivision;
  }

  public int numberOfSubDivision()
  {
    int number = subDivision.size();
    return number;
  }

  public boolean hasSubDivision()
  {
    boolean has = subDivision.size() > 0;
    return has;
  }

  public int indexOfSubDivision(Division aSubDivision)
  {
    int index = subDivision.indexOf(aSubDivision);
    return index;
  }

  public Division getDivision()
  {
    return division;
  }

  public boolean hasDivision()
  {
    boolean has = division != null;
    return has;
  }

  public static int minimumNumberOfEmployees()
  {
    return 0;
  }

  public Employee addEmployee(Person aPerson)
  {
    return new Employee(aPerson, this);
  }

  public boolean addEmployee(Employee aEmployee)
  {
    boolean wasAdded = false;
    if (employees.contains(aEmployee)) { return false; }
    Division existingDivision = aEmployee.getDivision();
    boolean isNewDivision = existingDivision != null && !this.equals(existingDivision);
    if (isNewDivision)
    {
      aEmployee.setDivision(this);
    }
    else
    {
      employees.add(aEmployee);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeEmployee(Employee aEmployee)
  {
    boolean wasRemoved = false;
    //Unable to remove aEmployee, as it must always have a division
    if (!this.equals(aEmployee.getDivision()))
    {
      employees.remove(aEmployee);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  public boolean addEmployeeAt(Employee aEmployee, int index)
  {  
    boolean wasAdded = false;
    if(addEmployee(aEmployee))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEmployees()) { index = numberOfEmployees() - 1; }
      employees.remove(aEmployee);
      employees.add(index, aEmployee);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveEmployeeAt(Employee aEmployee, int index)
  {
    boolean wasAdded = false;
    if(employees.contains(aEmployee))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfEmployees()) { index = numberOfEmployees() - 1; }
      employees.remove(aEmployee);
      employees.add(index, aEmployee);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addEmployeeAt(aEmployee, index);
    }
    return wasAdded;
  }

  public static int minimumNumberOfSubDivision()
  {
    return 0;
  }

  public boolean addSubDivision(Division aSubDivision)
  {
    boolean wasAdded = false;
    if (subDivision.contains(aSubDivision)) { return false; }
    Division existingDivision = aSubDivision.getDivision();
    if (existingDivision == null)
    {
      aSubDivision.setDivision(this);
    }
    else if (!this.equals(existingDivision))
    {
      existingDivision.removeSubDivision(aSubDivision);
      addSubDivision(aSubDivision);
    }
    else
    {
      subDivision.add(aSubDivision);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removeSubDivision(Division aSubDivision)
  {
    boolean wasRemoved = false;
    if (subDivision.contains(aSubDivision))
    {
      subDivision.remove(aSubDivision);
      aSubDivision.setDivision(null);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  public boolean addSubDivisionAt(Division aSubDivision, int index)
  {  
    boolean wasAdded = false;
    if(addSubDivision(aSubDivision))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfSubDivision()) { index = numberOfSubDivision() - 1; }
      subDivision.remove(aSubDivision);
      subDivision.add(index, aSubDivision);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveSubDivisionAt(Division aSubDivision, int index)
  {
    boolean wasAdded = false;
    if(subDivision.contains(aSubDivision))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfSubDivision()) { index = numberOfSubDivision() - 1; }
      subDivision.remove(aSubDivision);
      subDivision.add(index, aSubDivision);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addSubDivisionAt(aSubDivision, index);
    }
    return wasAdded;
  }

  public boolean setDivision(Division aDivision)
  {
    boolean wasSet = false;
    Division existingDivision = division;
    division = aDivision;
    if (existingDivision != null && !existingDivision.equals(aDivision))
    {
      existingDivision.removeSubDivision(this);
    }
    if (aDivision != null)
    {
      aDivision.addSubDivision(this);
    }
    wasSet = true;
    return wasSet;
  }

  public void delete()
  {
    for(int i=employees.size(); i > 0; i--)
    {
      Employee aEmployee = employees.get(i - 1);
      aEmployee.delete();
    }
    while( !subDivision.isEmpty() )
    {
      subDivision.get(0).setDivision(null);
    }
    if (division != null)
    {
      Division placeholderDivision = division;
      this.division = null;
      placeholderDivision.removeSubDivision(this);
    }
  }


  public String toString()
  {
    return super.toString() + "["+
            "name" + ":" + getName()+ "]";
  }
}



//%% NEW FILE Client BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 20 "../../../../../../ump/tmp746386/model.ump"
// line 101 "../../../../../../ump/tmp746386/model.ump"
public class Client extends PersonRole
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Client Attributes
  private String name;
  private String address;
  private String phoneNumber;

  //Client Associations
  private List<Account> accounts;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Client(Person aPerson, String aName, String aAddress, String aPhoneNumber)
  {
    super(aPerson);
    name = aName;
    address = aAddress;
    phoneNumber = aPhoneNumber;
    accounts = new ArrayList<Account>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setName(String aName)
  {
    boolean wasSet = false;
    name = aName;
    wasSet = true;
    return wasSet;
  }

  public boolean setAddress(String aAddress)
  {
    boolean wasSet = false;
    address = aAddress;
    wasSet = true;
    return wasSet;
  }

  public boolean setPhoneNumber(String aPhoneNumber)
  {
    boolean wasSet = false;
    phoneNumber = aPhoneNumber;
    wasSet = true;
    return wasSet;
  }

  public String getName()
  {
    return name;
  }

  public String getAddress()
  {
    return address;
  }

  public String getPhoneNumber()
  {
    return phoneNumber;
  }

  public Account getAccount(int index)
  {
    Account aAccount = accounts.get(index);
    return aAccount;
  }

  public List<Account> getAccounts()
  {
    List<Account> newAccounts = Collections.unmodifiableList(accounts);
    return newAccounts;
  }

  public int numberOfAccounts()
  {
    int number = accounts.size();
    return number;
  }

  public boolean hasAccounts()
  {
    boolean has = accounts.size() > 0;
    return has;
  }

  public int indexOfAccount(Account aAccount)
  {
    int index = accounts.indexOf(aAccount);
    return index;
  }

  public boolean isNumberOfAccountsValid()
  {
    boolean isValid = numberOfAccounts() >= minimumNumberOfAccounts();
    return isValid;
  }

  public static int minimumNumberOfAccounts()
  {
    return 1;
  }

  public boolean addAccount(Account aAccount)
  {
    boolean wasAdded = false;
    if (accounts.contains(aAccount)) { return false; }
    accounts.add(aAccount);
    if (aAccount.indexOfClient(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aAccount.addClient(this);
      if (!wasAdded)
      {
        accounts.remove(aAccount);
      }
    }
    return wasAdded;
  }

  public boolean removeAccount(Account aAccount)
  {
    boolean wasRemoved = false;
    if (!accounts.contains(aAccount))
    {
      return wasRemoved;
    }

    if (numberOfAccounts() <= minimumNumberOfAccounts())
    {
      return wasRemoved;
    }

    int oldIndex = accounts.indexOf(aAccount);
    accounts.remove(oldIndex);
    if (aAccount.indexOfClient(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aAccount.removeClient(this);
      if (!wasRemoved)
      {
        accounts.add(oldIndex,aAccount);
      }
    }
    return wasRemoved;
  }

  public boolean setAccounts(Account... newAccounts)
  {
    boolean wasSet = false;
    ArrayList<Account> verifiedAccounts = new ArrayList<Account>();
    for (Account aAccount : newAccounts)
    {
      if (verifiedAccounts.contains(aAccount))
      {
        continue;
      }
      verifiedAccounts.add(aAccount);
    }

    if (verifiedAccounts.size() != newAccounts.length || verifiedAccounts.size() < minimumNumberOfAccounts())
    {
      return wasSet;
    }

    ArrayList<Account> oldAccounts = new ArrayList<Account>(accounts);
    accounts.clear();
    for (Account aNewAccount : verifiedAccounts)
    {
      accounts.add(aNewAccount);
      if (oldAccounts.contains(aNewAccount))
      {
        oldAccounts.remove(aNewAccount);
      }
      else
      {
        aNewAccount.addClient(this);
      }
    }

    for (Account anOldAccount : oldAccounts)
    {
      anOldAccount.removeClient(this);
    }
    wasSet = true;
    return wasSet;
  }

  public boolean addAccountAt(Account aAccount, int index)
  {  
    boolean wasAdded = false;
    if(addAccount(aAccount))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccounts()) { index = numberOfAccounts() - 1; }
      accounts.remove(aAccount);
      accounts.add(index, aAccount);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveAccountAt(Account aAccount, int index)
  {
    boolean wasAdded = false;
    if(accounts.contains(aAccount))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccounts()) { index = numberOfAccounts() - 1; }
      accounts.remove(aAccount);
      accounts.add(index, aAccount);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addAccountAt(aAccount, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    ArrayList<Account> copyOfAccounts = new ArrayList<Account>(accounts);
    accounts.clear();
    for(Account aAccount : copyOfAccounts)
    {
      if (aAccount.numberOfClients() <= Account.minimumNumberOfClients())
      {
        aAccount.delete();
      }
      else
      {
        aAccount.removeClient(this);
      }
    }
    super.delete();
  }


  public String toString()
  {
    return super.toString() + "["+
            "name" + ":" + getName()+ "," +
            "address" + ":" + getAddress()+ "," +
            "phoneNumber" + ":" + getPhoneNumber()+ "]";
  }
}



//%% NEW FILE Privilege BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 49 "../../../../../../ump/tmp746386/model.ump"
// line 121 "../../../../../../ump/tmp746386/model.ump"
public class Privilege
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Privilege Attributes
  private String description;

  //Privilege Associations
  private List<AccountType> accountTypes;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Privilege(String aDescription)
  {
    description = aDescription;
    accountTypes = new ArrayList<AccountType>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setDescription(String aDescription)
  {
    boolean wasSet = false;
    description = aDescription;
    wasSet = true;
    return wasSet;
  }

  public String getDescription()
  {
    return description;
  }

  public AccountType getAccountType(int index)
  {
    AccountType aAccountType = accountTypes.get(index);
    return aAccountType;
  }

  public List<AccountType> getAccountTypes()
  {
    List<AccountType> newAccountTypes = Collections.unmodifiableList(accountTypes);
    return newAccountTypes;
  }

  public int numberOfAccountTypes()
  {
    int number = accountTypes.size();
    return number;
  }

  public boolean hasAccountTypes()
  {
    boolean has = accountTypes.size() > 0;
    return has;
  }

  public int indexOfAccountType(AccountType aAccountType)
  {
    int index = accountTypes.indexOf(aAccountType);
    return index;
  }

  public static int minimumNumberOfAccountTypes()
  {
    return 0;
  }

  public boolean addAccountType(AccountType aAccountType)
  {
    boolean wasAdded = false;
    if (accountTypes.contains(aAccountType)) { return false; }
    accountTypes.add(aAccountType);
    if (aAccountType.indexOfPrivilege(this) != -1)
    {
      wasAdded = true;
    }
    else
    {
      wasAdded = aAccountType.addPrivilege(this);
      if (!wasAdded)
      {
        accountTypes.remove(aAccountType);
      }
    }
    return wasAdded;
  }

  public boolean removeAccountType(AccountType aAccountType)
  {
    boolean wasRemoved = false;
    if (!accountTypes.contains(aAccountType))
    {
      return wasRemoved;
    }

    int oldIndex = accountTypes.indexOf(aAccountType);
    accountTypes.remove(oldIndex);
    if (aAccountType.indexOfPrivilege(this) == -1)
    {
      wasRemoved = true;
    }
    else
    {
      wasRemoved = aAccountType.removePrivilege(this);
      if (!wasRemoved)
      {
        accountTypes.add(oldIndex,aAccountType);
      }
    }
    return wasRemoved;
  }

  public boolean addAccountTypeAt(AccountType aAccountType, int index)
  {  
    boolean wasAdded = false;
    if(addAccountType(aAccountType))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccountTypes()) { index = numberOfAccountTypes() - 1; }
      accountTypes.remove(aAccountType);
      accountTypes.add(index, aAccountType);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMoveAccountTypeAt(AccountType aAccountType, int index)
  {
    boolean wasAdded = false;
    if(accountTypes.contains(aAccountType))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfAccountTypes()) { index = numberOfAccountTypes() - 1; }
      accountTypes.remove(aAccountType);
      accountTypes.add(index, aAccountType);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addAccountTypeAt(aAccountType, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    ArrayList<AccountType> copyOfAccountTypes = new ArrayList<AccountType>(accountTypes);
    accountTypes.clear();
    for(AccountType aAccountType : copyOfAccountTypes)
    {
      aAccountType.removePrivilege(this);
    }
  }


  public String toString()
  {
    return super.toString() + "["+
            "description" + ":" + getDescription()+ "]";
  }
}



//%% NEW FILE Person BEGINS HERE %%

/*PLEASE DO NOT EDIT THIS CODE*/
/*This code was generated using the UMPLE 1.25.0-89f4041 modeling language!*/

package BankingSystem.core.humanResources;
import java.util.*;

// line 8 "../../../../../../ump/tmp746386/model.ump"
// line 91 "../../../../../../ump/tmp746386/model.ump"
public class Person
{

  //------------------------
  // MEMBER VARIABLES
  //------------------------

  //Person Attributes
  private String name;
  private String address;
  private String phoneNumber;

  //Person Associations
  private List<PersonRole> personRoles;

  //------------------------
  // CONSTRUCTOR
  //------------------------

  public Person(String aName, String aAddress, String aPhoneNumber)
  {
    name = aName;
    address = aAddress;
    phoneNumber = aPhoneNumber;
    personRoles = new ArrayList<PersonRole>();
  }

  //------------------------
  // INTERFACE
  //------------------------

  public boolean setName(String aName)
  {
    boolean wasSet = false;
    name = aName;
    wasSet = true;
    return wasSet;
  }

  public boolean setAddress(String aAddress)
  {
    boolean wasSet = false;
    address = aAddress;
    wasSet = true;
    return wasSet;
  }

  public boolean setPhoneNumber(String aPhoneNumber)
  {
    boolean wasSet = false;
    phoneNumber = aPhoneNumber;
    wasSet = true;
    return wasSet;
  }

  public String getName()
  {
    return name;
  }

  public String getAddress()
  {
    return address;
  }

  public String getPhoneNumber()
  {
    return phoneNumber;
  }

  public PersonRole getPersonRole(int index)
  {
    PersonRole aPersonRole = personRoles.get(index);
    return aPersonRole;
  }

  public List<PersonRole> getPersonRoles()
  {
    List<PersonRole> newPersonRoles = Collections.unmodifiableList(personRoles);
    return newPersonRoles;
  }

  public int numberOfPersonRoles()
  {
    int number = personRoles.size();
    return number;
  }

  public boolean hasPersonRoles()
  {
    boolean has = personRoles.size() > 0;
    return has;
  }

  public int indexOfPersonRole(PersonRole aPersonRole)
  {
    int index = personRoles.indexOf(aPersonRole);
    return index;
  }

  public static int minimumNumberOfPersonRoles()
  {
    return 0;
  }

  public PersonRole addPersonRole()
  {
    return new PersonRole(this);
  }

  public boolean addPersonRole(PersonRole aPersonRole)
  {
    boolean wasAdded = false;
    if (personRoles.contains(aPersonRole)) { return false; }
    Person existingPerson = aPersonRole.getPerson();
    boolean isNewPerson = existingPerson != null && !this.equals(existingPerson);
    if (isNewPerson)
    {
      aPersonRole.setPerson(this);
    }
    else
    {
      personRoles.add(aPersonRole);
    }
    wasAdded = true;
    return wasAdded;
  }

  public boolean removePersonRole(PersonRole aPersonRole)
  {
    boolean wasRemoved = false;
    //Unable to remove aPersonRole, as it must always have a person
    if (!this.equals(aPersonRole.getPerson()))
    {
      personRoles.remove(aPersonRole);
      wasRemoved = true;
    }
    return wasRemoved;
  }

  public boolean addPersonRoleAt(PersonRole aPersonRole, int index)
  {  
    boolean wasAdded = false;
    if(addPersonRole(aPersonRole))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPersonRoles()) { index = numberOfPersonRoles() - 1; }
      personRoles.remove(aPersonRole);
      personRoles.add(index, aPersonRole);
      wasAdded = true;
    }
    return wasAdded;
  }

  public boolean addOrMovePersonRoleAt(PersonRole aPersonRole, int index)
  {
    boolean wasAdded = false;
    if(personRoles.contains(aPersonRole))
    {
      if(index < 0 ) { index = 0; }
      if(index > numberOfPersonRoles()) { index = numberOfPersonRoles() - 1; }
      personRoles.remove(aPersonRole);
      personRoles.add(index, aPersonRole);
      wasAdded = true;
    } 
    else 
    {
      wasAdded = addPersonRoleAt(aPersonRole, index);
    }
    return wasAdded;
  }

  public void delete()
  {
    for(int i=personRoles.size(); i > 0; i--)
    {
      PersonRole aPersonRole = personRoles.get(i - 1);
      aPersonRole.delete();
    }
  }


  public String toString()
  {
    return super.toString() + "["+
            "name" + ":" + getName()+ "," +
            "address" + ":" + getAddress()+ "," +
            "phoneNumber" + ":" + getPhoneNumber()+ "]";
  }
}